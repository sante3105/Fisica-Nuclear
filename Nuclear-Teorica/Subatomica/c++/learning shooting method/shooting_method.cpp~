#include <cmath>#include <fstream>#include <iostream>#include <string>#include <sys/stat.h>#include <gsl/gsl_errno.h>#include <gsl/gsl_odeiv2.h>#include <gsl/gsl_roots.h>constexpr double kX0 = 0.0;constexpr double kX1 = M_PI_2; //3.14;  // BVP endpointconstexpr double kY0 = 0.0;constexpr double kY1 = 1.0;// ODE system: y1' = y2, y2' = -y1int ode_system(double /*x*/, const double y[], double dydx[], void* /*params*/) {  dydx[0] = y[1];  dydx[1] = -y[0];  return GSL_SUCCESS;}// Integrate ODE from x0 to x1 and return y1(x1)double integrate_ode(double s_guess) {  gsl_odeiv2_system sys = {ode_system, nullptr, 2, nullptr};  gsl_odeiv2_driver* driver = gsl_odeiv2_driver_alloc_y_new(      &sys, gsl_odeiv2_step_rk8pd, 1e-6, 1e-6, 0.0);  double x = kX0;  double y[2] = {kY0, s_guess};  int status = gsl_odeiv2_driver_apply(driver, &x, kX1, y);  gsl_odeiv2_driver_free(driver);  if (status != GSL_SUCCESS) return NAN;  return y[0];}// Root function for Brent solver: f(s) = y1(x1; s) - y1_targetdouble shoot_function(double s, void* /*params*/) {  return integrate_ode(s) - kY1;}// Create directory if it doesn't existvoid ensure_directory_exists(const std::string& dir_path) {  #ifdef _WIN32    mkdir(dir_path.c_str());  #else    mkdir(dir_path.c_str(), 0755);  #endif}// Dump full trajectory up to x=4.0 for Gnuplot animationvoid DumpTrajectory(double s_guess, int iteration_index) {  gsl_odeiv2_system sys = {ode_system, nullptr, 2, nullptr};  gsl_odeiv2_driver* driver = gsl_odeiv2_driver_alloc_y_new(      &sys, gsl_odeiv2_step_rk8pd, 1e-6, 1e-6, 0.0);     ensure_directory_exists("data");     std::ofstream out("data/shoot" + std::to_string(iteration_index) + ".dat");   if (!out.is_open()) {    std::cerr << "Error: Could not open file for writing\n";    gsl_odeiv2_driver_free(driver);    return;  }  // Include the s_guess in the file header as a comment  out << "# Iteration " << iteration_index << ", Initial slope guess: " << s_guess << "\n";  double x = kX0;  double y[2] = {kY0, s_guess};  out << x << " " << y[0] << "\n";  while (x < 4.0) {    double next_x = x + 0.01;    int status = gsl_odeiv2_driver_apply(driver, &x, next_x, y);    if (status != GSL_SUCCESS) break;    out << x << " " << y[0] << "\n";  }  gsl_odeiv2_driver_free(driver);}int main() {  // Create the data directory at program start  ensure_directory_exists("data");  gsl_function F;  F.function = shoot_function;  F.params = nullptr;  // Initialize params even though unused   double s_lo = 0.0;   double s_hi = 3.0;   // Check if the function changes sign in the initial interval  double f_lo = shoot_function(s_lo, nullptr);  double f_hi = shoot_function(s_hi, nullptr);  std::cout << "Initial bracket: [" << s_lo << ", " << s_hi << "]\n";  std::cout << "f(" << s_lo << ") = " << f_lo << "\n";  std::cout << "f(" << s_hi << ") = " << f_hi << "\n";   // Check if signs are the same  if (f_lo * f_hi > 0) {    std::cout << "Warning: Function does not change sign in the initial interval.\n";    std::cout << "Attempting to find a bracket where the function changes sign...\n";        // Try to find a bracket where the function changes sign    bool found_bracket = false;        // First, try expanding the right end of the interval    double new_hi = s_hi;    for (int i = 0; i < 10; i++) {      new_hi *= 2; // Double the upper bound      double f_new_hi = shoot_function(new_hi, nullptr);      std::cout << "Trying s_hi = " << new_hi << ", f(s_hi) = " << f_new_hi << "\n";            if (f_lo * f_new_hi < 0) {        s_hi = new_hi;        f_hi = f_new_hi;        found_bracket = true;        std::cout << "Found bracket: [" << s_lo << ", " << s_hi << "]\n";        break;      }    }        // If that didn't work, try with negative values for s_lo    if (!found_bracket && f_lo > 0) {      double new_lo = -1.0;      for (int i = 0; i < 10; i++) {        double f_new_lo = shoot_function(new_lo, nullptr);        std::cout << "Trying s_lo = " << new_lo << ", f(s_lo) = " << f_new_lo << "\n";                if (f_new_lo * f_hi < 0) {          s_lo = new_lo;          f_lo = f_new_lo;          found_bracket = true;          std::cout << "Found bracket: [" << s_lo << ", " << s_hi << "]\n";          break;        }                // Try a more negative value        new_lo *= 2;      }    }        if (!found_bracket) {      std::cerr << "Error: Could not find an interval where the function changes sign.\n";      std::cerr << "The shooting method cannot proceed without a proper bracket.\n";      return 1;    }  }      // Save the initial guesses trajectories  std::cout << "Generating trajectories for initial guesses...\n";  DumpTrajectory(s_lo, 0);  // Save trajectory for lower bound  DumpTrajectory((s_lo + s_hi)/2, -1);  // Save trajectory for middle point  DumpTrajectory(s_hi, -2);  // Save trajectory for upper bound    gsl_root_fsolver* solver = gsl_root_fsolver_alloc(gsl_root_fsolver_brent);  gsl_root_fsolver_set(solver, &F, s_lo, s_hi);  int iter = 0;  int status;  double r ; // Print header for iteration info  std::cout << "Iter    Lower       Upper       Current Root  f(root)\n";  std::cout << "----------------------------------------------------\n";    do {    iter++;    status = gsl_root_fsolver_iterate(solver);        if (status != GSL_SUCCESS) {      std::cerr << "Error during iteration: " << gsl_strerror(status) << std::endl;      break;    }    r = gsl_root_fsolver_root(solver);    double x_lo = gsl_root_fsolver_x_lower(solver);    double x_hi = gsl_root_fsolver_x_upper(solver);    double f_r = shoot_function(r, nullptr);        // Print iteration info    printf("%3d  %.8f  %.8f  %.8f  %.8e\n", iter, x_lo, x_hi, r, f_r);     DumpTrajectory(r, iter);  // Save this guess's trajectory         status = gsl_root_test_interval(x_lo, x_hi, 1e-6, 0.0);  } while (status == GSL_CONTINUE && iter < 20);    if (status == GSL_SUCCESS) {    std::cout << "Final slope y'(0): " << r << "\n";    std::cout << "Final y(pi/2): " << integrate_ode(r) << "\n";  } else if (iter >= 20) {    std::cout << "Warning: Failed to converge after maximum iterations\n";    std::cout << "Current estimate y'(0): " << r << "\n";    std::cout << "Current y(pi/2): " << integrate_ode(r) << "\n";  }    gsl_root_fsolver_free(solver);  return 0;}